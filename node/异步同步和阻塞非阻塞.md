
在接触 Node.js 时，会听到异步，非阻塞，回调，事件这些词语，其中异步和非阻塞听起来似乎时一回事，从实际效果的角度来说，异步和非阻塞都达到了并行执行内核空间 I/O 的目的。

但从计算机内核 I/O 而言，异步/同步和阻塞/非阻塞时两回事。

### 一、I/O 的阻塞和非阻塞

阻塞模式的 I/O 会造成应用程序等待，直到 I/O 完成。同时，操作系统也支持将 I/O 操作设置为非阻塞模式，这时应用程序的调用将可能在没有拿到真正数据时就立即返回了，为此应用程序需要多次调用才能确认 I/O 操作完全完成。

### 二、I/O 的同步和异步

I/O 的同步和异步出现在应用程序中。如果做阻塞 I/O 调用，应用程序等待调用的完成的过程就是一种同步状况。相反，I/O 为非阻塞模式时，应用程序则时异步的。

### 三、异步 I/O 与轮询技术

当进行非阻塞 I/O 调用时，要想读取完整的数据，应用程序需要进行多次轮询。

轮询技术的缺点在于，应用程序要主动调用，会造成占用较多 CPU 时间片，性能较低。现在的轮询技术包含 read/select/poll/epoll/pselect/kqueue。read 是性能最低的一种，它通过重复调用来检查 I/O 的状态来完成数据读取。select 是一种改进方案，通过对文件描述符上的事件状态来进行判断。poll/epoll 是采用多路复用技术的更高效的方案。

回到正题，轮询技术虽然满足来非阻塞 I/O 获取完整数据的保证，但对于应用程序来说，它仍然只算是一种同步，因为应用程序仍需要主动去判断 I/O 状态，依旧要占用很多 CPU 资源。


### 四、理想的异步 I/O 模型

理想方案：

应用程序发起异步调用，不需要进行轮询，可以直接处理后续任务，只需要在 I/O 完成后通过信号或是回调将数据传递给应用程序即可。

幸运地是
