🐾 泛型的使用

🕘 2019.10.12 由 hoanfirst 编辑


**在typeScript中，泛型是一种支持`可复用代码组件`的工具**。简单的来说，通过泛型，开发者可以将同一套代码组件用于任意类型的输入，实现复用。

### 在没有使用泛型之前

```javascript

class Test {
  constructor() {
    this.names = [];
  }
  get(index: number): string {
    return this.names[index];
  }
  add(item: string) {
    this.names.push(item);
  }
}

```

对于上面的类，很明显可以知道其用于一个string类型的集合。但如果想要将里面的业务逻辑用于number类型的，就不可以了。只能重新创建：

```javascript

class TestString {
  constructor() {
    this.names = [];
  }
  get(index: number): string {
    return this.names[index];
  }
  add(item: string) {
    this.names.push(item);
  }
}

class TestNumber {
  constructor() {
    this.ages = [];
  }
  get(index: number): number {
    return this.ages[index];
  }
  add(item: number) {
    this.ages.push(item);
  }
}

```

从上面的代码看，很明显出现了一个很大的问题——**代码重复**，最终导致编写成本和调试成本增多，并且降低内存的执行效率。

### 使用any类型

既然为了适用于不同或者说任意类型的参数，那直接使用any类型呢？

```javascript

class Test {
  constructor() {
    this.args = [];
  }
  get(index: number): any {
    return this.args[index];
  }
  add(item: any) {
    this.args.push(item);
  }
}

```

但typescript不建议使用any类型：

- 违背了typescript出现的初衷

- 调试时缺乏完整的信息

### 引入泛型

- 语法

```javascript

//在函数上使用
function identity<T>(agr: T): T {
  return arg;
}

//在类上使用
class Test<T> {
  constructor() {
    this.args = [];
  }
  get(index: number): T {
    return this.args[index];
  }
  add(item: T) {
    this.args.push(number);
  }
}

let Strings = new Test<String>();
let Numbers = nwe Test<Number>();

//在实例方法上使用
class Test {
  constructor() {
    this.args = [];
  }
  add<A>(item: A): void {
    this._things.push(item);
  }
  get<B>(index: number): B {
    return this.args[index];
  }
}

//在静态方法上使用
class Test {
  private _args: any[];
  constructor() {
    this._args = [];
  }
  static add<A>(item: A): void {
    _args.push(item);
  }
  get<B>(index: number): B {
    return this._args[index];
  }
}

```

尖括号里面的T，就表明使用时传入的参数。在使用时可以传入任意类型的数据。

### 引入泛型约束

直接使用泛型，是有缺陷的。

使用泛型，许多属性的类型都能被typeScript推断出来，然而，在某些typeScript不能做出准确推断的地方，它不会做任何假设。

为了类型安全，你需要将这些要求或者约束定义为`接口`，并在泛型初始化中继承它们。

```javascript

//1. 不使用泛型约束
function printName<T>(arg: T) {
  console.log(arg.length);
  return arg;
}
printName(3);
//在这个函数里，typescript就不能做出准确推断arg是什么类型，也就不能证明是不是含有length属性。

//2. 使用泛型约束
interface NameArgs {
  length: number;
}

function printName<T extends NameArgs>(arg: T) {
  console.log(arg.length);
  return arg;
}

```
