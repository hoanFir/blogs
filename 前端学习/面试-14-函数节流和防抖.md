
# 一、什么是函数节流和防抖

throttling，节流；debouncing，防抖。

防止某个函数在短时间内多次自动触发，比如 scroll、mouseover 和 resize 等会频繁触发的事件。


# 二、为何引入

常见场景：在在 scroll 滚动事件中绑定回调，实现图片懒加载、下拉自动加载数据以及侧边浮动导航栏等。

问题：产生性能问题。上述的这类事件往往涉及到大量的位置计算、DOM操作、元素重绘等工作。一个事件所需完成的工作无法在下一个事件触发前完成，从而造成浏览器掉帧，尤其是对于 scroll 事件，用户鼠标滚动是连续的，就会持续触发 scroll 事件导致浏览器 CPU 使用率增加，掉帧严重，用户体验受到影响。



# 三、如何实现

## 3.1 定时器函数防抖/去抖动

利用 `setTimeout` 定时器，保证其在一段时间内至少触发一次，这是节流的变种。

```javascript
function debounce(func, delay, mustRun) {
	var timer = null, start = null;
	
	return function() {
		let args = arguments, context = this, cur = new Date();
		clearTimeout(timer);
		
		if(!start) { start = cur };
		if(cur-start > mustRun) {
			func.apply(context, args);
			start = cur;
		} else {
			timer = setTimeout(function() {
				func.apply(context, args);
			}, delay);
		}
	}
}
```

## 3.2 定时器函数节流

函数防抖会存在问题，比如图片懒加载，用户希望在下来过程中图片不断被家在出来，而不是停止下拉的时候才加载出来。

利用 `setTimeout` 延时触发函数，如果在延时前重复触发函数，清除上次延时，重新设定新的延时。

存在的缺陷：如果一直快速快速触发函数，会导致函数永远无法执行（不过一般不会有这种情况）

```javascript
//方式一
function throttle(func, delay) {
	return function() {
		let args = arguments, context = this;
		//let _that = this;
		clearTimeout(func.id);
		
		func.id = setTimeout(function() {
			func.apply(context, args);
		}, delay);
	}
}

//方式二（+闭包）
function throttle(func, delay) {
	var timer = null;
	
	return function() {
		let args = arguments, context = this;
		clearTimeout(timer);
		
		timer = setTimeout(function() {
			func.apply(context, args);
		}, delay);
	}
}
```


