
# 一、什么是函数节流和防抖

throttling，节流；debouncing，防抖。

防止某个函数在极短时间内多次自动触发，比如 scroll、mouseover 和 resize 等会频繁触发的事件。


# 二、为何引入

常见场景：在 scroll 滚动事件中绑定回调，实现图片懒加载、下拉自动加载数据或侧边浮动导航栏等。

问题：容易产生性能问题。

分析：因为对于上述的这类事件，往往涉及到大量的 reflow 和 repaint 等工作。如果极短时间内执行多次回调，会导致一个回调所需完成的工作无法在下一个回调触发前完成，就会造成掉帧，导致浏览器 CPU 使用率增加，用户体验受到影响。当用户浏览网页，拥有平滑滚动是很重要的体验。



# 三、如何实现

注意，由于 scroll 事件本身会触发页面的重新渲染，同时其 handler 会被频繁的触发，因此建议 handler 里不应该有过于复杂的操作，如 DOM 操作。

## 3.1 定时器函数防抖

如，假如在 500 ms 内没有连续触发事件，才会触发下一次事件。


```javascript

//1

function debounce(func, wait) {
	var timer = null;
	
	return function () {
		clearTimeout(timer);
		
		timer = setTimeout(func, wait);
	};
}

function handlerFunc() {
	console.log("hello");
}

window.addEventListener('scroll', debounce(handlerFunc, 500));

```

## 3.2 定时器函数节流

函数防抖虽然不错，但会存在问题，比如图片懒加载，用户希望在下来过程中图片不断被加载出来，而不是停止下拉后过了 500 ms 才加载出来。

而通过节流，可以实现滚动的时候也可以以一定的频率触发事件，即在一定时间内，必然触发一次事件。

利用 `setTimeout` 延时触发函数，如果在延时前重复触发函数，清除上次延时，重新设定新的延时。

存在的缺陷：如果一直快速快速触发函数，会导致函数永远无法执行（不过一般不会有这种情况）

```javascript

```


