
# 什么是函数节流&函数防抖
防止某个函数在短时间内多次自动触发（隔一段时间自动触发），导致性能问题

# 如何实现
`闭包` + `定时器setTimeout`

## 2. 定时器函数节流
利用 `setTimeout` 延时触发函数，如果在延时前重复触发函数，清除上次延时，重新设定新的延时。

存在的缺陷：如果一直快速快速触发函数，会导致函数永远无法执行（不过一般不会有这种情况）

```javascript
//方式一
function throttle(func, delay) {
	return function() {
		let args = arguments, context = this;
		//let _that = this;
		clearTimeout(func.id);
		
		func.id = setTimeout(function() {
			func.apply(context, args);
		}, delay);
	}
}

//方式二（+闭包）
function throttle(func, delay) {
	var timer = null;
	
	return function() {
		let args = arguments, context = this;
		clearTimeout(timer);
		
		timer = setTimeout(function() {
			func.apply(context, args);
		}, delay);
	}
}
```

## 3. 定时器函数防抖/去抖动
利用 `setTimeout`，保证其在一段时间内至少触发一次，这是节流的变种

```javascript
function debounce(func, delay, mustRun) {
	var timer = null, start = null;
	
	return function() {
		let args = arguments, context = this, cur = new Date();
		clearTimeout(timer);
		
		if(!start) { start = cur };
		if(cur-start > mustRun) {
			func.apply(context, args);
			start = cur;
		} else {
			timer = setTimeout(function() {
				func.apply(context, args);
			}, delay);
		}
	}
}
```
