
# 一、什么是函数节流和防抖

throttling，节流；debouncing，防抖。

防止某个函数在极短时间内多次自动触发，比如 scroll、mouseover 和 resize 等会频繁触发的事件。


# 二、为何引入

常见场景：在 scroll 滚动事件中绑定回调，实现图片懒加载、下拉自动加载数据或侧边浮动导航栏等。

问题：容易产生性能问题。因为上述的这类事件，往往涉及到大量的位置计算、DOM操作和重绘等工作。如果一个事件所需完成的工作无法在下一个事件触发前完成，就会造成掉帧，尤其是对于 scroll 事件，用户鼠标滚动往往是连续的，会持续触发 scroll 事件，导致浏览器 CPU 使用率增加，掉帧严重，用户体验受到影响。当用户浏览网页，拥有平滑滚动是很重要的体验。



# 三、如何实现

## 3.1 定时器函数防抖/去抖动

利用 `setTimeout` 定时器，保证其在一段时间内至少触发一次，这是节流的变种。

```javascript

function debounce(func, delay, mustRun) {
	var timer = null, start = null;
	
	return function() {
		let args = arguments, context = this, cur = new Date();
		clearTimeout(timer);
		
		if(!start) { start = cur };
		if(cur-start > mustRun) {
			func.apply(context, args);
			start = cur;
		} else {
			timer = setTimeout(function() {
				func.apply(context, args);
			}, delay);
		}
	}
}

```

## 3.2 定时器函数节流

函数防抖会存在问题，比如图片懒加载，用户希望在下来过程中图片不断被家在出来，而不是停止下拉的时候才加载出来。而通过使用节流，可以实现滚动的时候也可以以一定的频率触发事件，即在一定时间内，必然触发一次事件。

利用 `setTimeout` 延时触发函数，如果在延时前重复触发函数，清除上次延时，重新设定新的延时。

存在的缺陷：如果一直快速快速触发函数，会导致函数永远无法执行（不过一般不会有这种情况）

```javascript
//方式一
function throttle(func, delay) {
	return function() {
		let args = arguments, context = this;
		//let _that = this;
		clearTimeout(func.id);
		
		func.id = setTimeout(function() {
			func.apply(context, args);
		}, delay);
	}
}

//方式二（+闭包）
function throttle(func, delay) {
	var timer = null;
	
	return function() {
		let args = arguments, context = this;
		clearTimeout(timer);
		
		timer = setTimeout(function() {
			func.apply(context, args);
		}, delay);
	}
}
```


