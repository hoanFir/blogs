

使用 Object 构造函数和对象字面量创建单个对象，有明显的缺点：需要使用同一个接口创建很多对象时，会产生大量重复代码。

为了解决上述问题，开始了一系列的发展。

### 一、工厂模式

这种模式抽象了创建具体对象的过程，ECMAScript 实现：用一种函数来封装以特定接口创建对象的细节。

```javascript

function createPerson(name, age, job) {
  var o = new Object();
  
  o.name = name;
  o.age = age;
  o.job = job;
  
  o.sayName = function() {};
  
  return o;
}

var person1 = createPerson('', '', '')
var person2 = createPerson('', '', '')


```

### 问题

工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别但问题，即怎么样知道一个对象的类型。


### 二、构造函数模式

ECMAScript 中的构造函数可以用来创建特定类型的对象。像 Object 或 Array 这样的原生构造函数，在运行时会自动出现在执行环境中。

此外，也可以创建**自定义的构造函数**，从而实现自定义对象类型的属性和方法。

```javascript

//按照惯例，构造函数始终都以一个大写字母开头，该做法借鉴于其他 OO 语言，主要是为了区别于 ECMAScript 的其他函数

function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  
  this.sayName = function() {};
}

var person1 = new Person('', '', '')
var person2 = new Person('', '', '')

```
在上述代码中，使用构造函数模式，直接把属性和方法赋给了 this 对象。

person1 和 person2 分别保存着 Person 的一个不同的实例。**这两个对象都有一个 constructor 属性，都指向 Person**，这也解决工厂模式存在的问题，即怎么样知道一个对象的类型。

但，要检测对象类型，还是推荐使用 instanceof。使用了构造函数模式创建对象之后，支持 instanceof 操作符判断当前对象类型：

```javascript

person1 instanceif Object == true
person1 instanceif Person == true
person2 instanceif Person == true

```

注意，构造函数本身也是函数，只不过用来创建对象而已。

### 问题

使用构造函数的主要问题，就是每个方法，都要在每个实例上创建一遍。

为什么这么说？

```

在前面的例子里，person1 和 person2 都有一个名为 sayName() 的方法，但那两个方法不是同一个 Function 的实例，不要忘了—— ECMAScript 中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。

从逻辑角度讲，构造函数里的方法也可以这样定义：

this.sayName = new Function("..."); //与声明函数在逻辑上是等价的

从这个角度上看构造函数，更容易理解，每个 Person 实例都包含一个不同的 Function 实例的本质。即不同实例上的同名函数是不相等的。

person1.sayNam !== person2.sayName

```

但是，创建两个完成同样任务的 Function 实例很明显是没有必要的。


### 三、原型模式

对于 ECMAScript 中的引用类型来说，prototype 是保存它们所有实例方法的真正所在。换句话说，诸如 toString() 和 valueOf() 等方法实际上都保存在 prototype 里，只不过通过各自对象的实例访问罢了。

因此，我们创建的每一个函数，都有一个 prototype 属性，这个属性是一个指针，指向一个对象。该对象的
用途是：保存可以由特定类型的所有实例共享的属性和方法。换句话说，**prototype 就是通过调用构造函数而创建的那个对象实例的原型对象**。

使用原型对象的好处就是：让所有实例共享属性和方法。


```javascript

function Person() {
}

Person.prototype.name = "t";
Person.prototype.age = 12;
Person.prototype.job = "car";
Person.prototype.sayName = function() {};

var person1 = new Person();
var person2 = new Person();

person1.sayName = person2.sayName

```

### 四、组合构造函数模式和原型模式

```javascript

function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job; 
}

Person.prototype.sayName = function() {};

var person1 = new Person('', '', '')
var person2 = new Person('', '', '')

person1.sayName = person2.sayName

```


