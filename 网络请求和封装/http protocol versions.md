

http/2 相比于 http/1.1，大幅度提升了网页的性能。不过也存在兼容问题和如何优雅降级问题...

http/3 相比于 http/2，解决了后者存在的一些问题...


[原文](https://mp.weixin.qq.com/s/5jR7MrWQ9v3w_E8BhNWrpA)

## http/1.1

HTTP/1.1 自从 1997 年发布以来，随着互联网发展，从当初网页内容以文本为主, 到现在以富媒体（如图片、声音、视频）为主, 而且对页面内容实时性越来越高 （如聊天、视频直播），传输数据大小与平均请求资源数量不断持续增长, 于是当时协议规定的某些特性，已经无法满足现代网络的需求了。

### 1.1 网络延迟

随着互联网发展，网络带宽增长非常快，但网络延迟并没有对应程度的降低，网络延迟问题主要由于**队头阻塞 (Head-Of-Line Blocking)** 产生，导致带宽无法被充分利用。队头阻塞是指，当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致接收端迟迟收不到数据。

一些方案：主要是针对请求资源数量多的情况

- 针对六浏览器对于同一个域名只允许 6 个 TCP 连接的限制，可以将资源分散到不同的域名下，从而提升连接上限

- 合并多张小图为一张大图, 再用 JavaScript 或者 CSS 将小图重新“切割”出来的技术，从而减小网络请求次数

- 小图片以base64格式直接嵌入文件中，从而避免请求很多小图片。如`.icon { background: url(data:image/png;base64,<data>) no-repeat; }`

- 打包技术，如webpack，也是为了减少网络请求次数

- ...


### 1.2 无状态

因为 http 协议是无状态的，所以一般一个请求会携带许多 headers 维护连接状态，如"User Agent"
"Cookie""Accept""Server"等许多固定的头字段，这些字段多达几百字节甚至上千字节，但 Body 却经常只有几十字节，因此这一定程度上增加了网络传输成本

### 1.3 明文传输

tips：https主要就是针对http明文传输问题和数据完整性问题

HTTP/1.1 在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性，因为攻击者可以直接截取你发送的请求中的数据，甚至泄漏了账户密码、银行卡号等敏感信息

### 1.4 不支持服务器向客户端推送信息

tips：websocket 协议是 HTML 5 引入的一种新协议，可实现客户端和服务器的全双工通信。和 http 协议都是应用层协议，都是基于 tcp，需要知道的是 websocket 在建立握手时数据是通过 http 传输的，在建立之后的真正传输过程不再需要 http


## 2. SPDY

通过上面的分析，我们知道**Http/1.1 有两个主要的缺点：性能不高、安全不足。**

直到 2009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 Http/1.1 效率不高的问题，才算是正式改造 Http 协议本身，降低延迟，压缩 header 等等，SPDY 的实践证明了这些优化的效果，也最终带来 Http/2 的诞生。

SPDY 协议为了避免改造 http/1.1 带来的兼容问题，它采用存在于 http 协议之下，ssl 和 tcp 协议之上的形式，这样就可以轻松兼容老版本的 HTTP 协议 (将 HTTP1.x 的内容封装成一种新的 frame 格式)，同时可以使用已有的 SSL 功能。

## 3. http/2

SPDY 协议在 Chrome 浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 中得到继承。

2015 年，Http/2 发布。**Http/2 基于 SPDY，专注于性能（https专注于安全），最大的目标是在用户和网站间只用一个连接。**

首先，http/2 由两个规范（Specification）组成：

- Hypertext Transfer Protocol version 2 - RFC7540

- HPACK - Header Compression for HTTP/2 - RFC7541



### 3.1 二进制传输

http/2 采用二进制格式传输数据，而非 HTTP/1.x 里纯文本形式的报文 ，二进制协议解析起来更高效。具体点说，http/2 将请求和响应数据分割为更小的帧，并且采用二进制编码。

http/2 把 TCP 协议的部分特性挪到了应用层，把原来的"Header+Body"的消息"打散"为数个小片的二进制"帧"(Frame), 用"HEADERS"帧存放头数据、"DATA"帧存放实体数据。

http/2 数据分帧后，协议看到的只是一个个"碎片"。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，只需根据帧首部的流标识重新组装。



### 3.2 Header 压缩

http/2 并没有使用传统的压缩算法，而是开发了专门的"HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到 50%~90% 的高压缩率。

具体：

- 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送

- “首部表”在 http/2 的连接期间内始终存在，由客户端和服务器共同更新和维护

- 每个新的首部键值对会被追加到“首部表”末尾或者替换之前到值

比如，请求A发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。



### 3.3 多路复用技术

多路复用技术很好的解决了“浏览器限制同一个域名下请求数量”的问题。而且也更容易实现全速传输（新开一个 TCP 连接都需要慢慢提升传输速度）。

- 同域名下所有通信都在单个连接上完成，即只需要占用一个 TCP 连接。使用一个连接并行发送多个请求和响应, 这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题

- 单个连接可以承载任意数量的双向数据流

- 每个数据流都以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，只需根据帧首部的流标识重新组装

- 每个请求都可以带一个 31bit 大小的优先值，0 表示最高优先级，数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。


### 3.4 Server Push

http/2 中服务器可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，不需要解析html后才发请求，减少等待的延迟，这被称为"服务器推送"，Server Push，也叫 Cache push。

- 服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送 `RST_STREAM` 帧来拒收

- 服务端主动推送也遵守浏览器的同源策略。换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行


### 3.5 提高安全性

出于兼容的考虑，http/2 延续了 http/1 的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信。

但由于 HTTPS 已经是大势所趋，而且主流的浏览器 Chrome、Firefox 等都公开宣布只支持加密的 HTTP/2，所以“事实上”的 HTTP/2 是加密的。也就是说，互联网上通常所能见到的 HTTP/2 都是使用"https”协议，跑在 TLS 上面。

HTTP/2 协议定义了两个字符串标识符：“h2"表示加密的 HTTP/2，“h2c”表示明文的 HTTP/2。



## 4. http/3

...
