## 一、受限制的线性表

对于栈来说：新增只能在表末端进行，删除只能在表始端进行。


## 二、队列操作

先进。

先出。


## 三、如何用数组实现队列/顺序队列

1. 把数组首元素作为队首，定义一个 front 指针指向首元素，最后一个元素作为队尾，定义一个 rear 指针指向尾元素

2. 当进行新增操作，直接在数组末尾插入，不影响数组，但要保证不溢出/越界。记得移动 rear 指针指向新插入的元素

3. 当进行删除操作，首先要把数组首元素删除，然后把后续元素往前移动一位。记得把 front 指针指向新的首元素

4. 当 rear === front，有可能是队列满，也可能是队列空。可以设置一个 flag 变量来判断



注意，**我们发现在进行删除操作时，需要移动n-1个元素，直接把时间复杂度变为O(n)**。如何避免？

```

方案：删除首元素之后不移动后面的其他元素，而是直接移动 front 指针到第二个元素

```

但是，这样的数组还存在一个问题：如果不断删除第一个元素和新增元素后，会出现假溢出/假越界，即数组前面都是删除结点后遗留的空闲空间。如何避免？

```

方案1：开辟足够大的内存空间确保数组不会溢出



方案2：对队列进行特殊变种，使用循环队列。

- 当进行新增操作，首先判断数组是否已满，不是则判断 rear 指针是否指向最后一个位置，如果不是，则直接将新元素插入到数组末尾，如果是，移动 rear 指针指向数组首部。如此重复

- 当进行删除操作，首先判断队列是否为空，不是则判断是否当前 front 是否指向最后一个位置，如果不是，则直接移动 front 指针向后一个位置，如果是，移动 front 指针指向数组首部。如此重复




```



## 四、如何用链表实现队列/链式队列

1. 把队首放在链表的头部，定义一个 front 指针指向头结点（注意，不是队头。头结点不存储数据，只是用来辅助标识）。把队尾放在链表的尾部，定义一个 rear 指针指向队尾

2. 当进行新增操作，将链表尾部元素 rear.next 指向新增元素，并移动 rear 指针指向新队尾

3. 当进行删除操作，实际删除的是头结点 front.next，即后继结点

4. 当队列为空时，front 和 raer 指针都指向链表头结点，即 front === rear






