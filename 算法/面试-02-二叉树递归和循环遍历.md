
二叉树三种遍历都有递归和循环的实现方法，递归实现都比循环实现要简洁的多。

## 前序遍历

递归遍历

```c

void PreOrderTraverse(BinaryTreeNode* pTreeRoot) {

  if(pTreeRoot != NULL) {
    printf("%c", pTreeRoot->value);
    
    PreOrderTraverse(pTreeRoot->pLeft);
    PreOrderTraverse(pTreeRoot->pRight);
  }
}

```

非递归遍历

从根节点沿左子树一直深入，直到最左端的叶子节点，返回，进入当前叶子节点父节点的右子树，再进行如此的深入和返回，直到最后从根节点的右子树返回到根节点为止。

**对于前序变遍历，进行如上遍历，然后遇到节点就打印。**

```


```


## 中序遍历

递归遍历


```c

void InOrderTraverse(BinaryTreeNode* pTreeRoot) {

  if(pTreeRoot != NULL) {    
    InOrderTraverse(pTreeRoot->pLeft);
    
    printf("%c", pTreeRoot->value);
    
    InOrderTraverse(pTreeRoot->pRight);
  }
}

```

## 后序遍历

递归遍历

```c

void PostOrderTraverse(BinaryTreeNode* pTreeRoot) {

  if(pTreeRoot != NULL) {    
    PostOrderTraverse(pTreeRoot->pLeft);
    PostOrderTraverse(pTreeRoot->pRight);
    
    printf("%c", pTreeRoot->value);
  }
}

```
