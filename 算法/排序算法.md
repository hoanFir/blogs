🐾 排序算法

🕘 2019.10.20 由 hoanfirst 编辑

排序算法

> 原文 《吴军的谷歌方法论》 – 从计算机的算法，谈谈提高效率的本质

### 人类平时会遇到排序的的场景：

- 如果只有三五个数字，肉眼扫描就可以排序好
- 如果是几十个数字，就需要严格遵守一个排序流程，否则容易出现小错误

对于第二种场景，一般有如下不会出现错误的排序方法：

- **冒泡排序**。每一次从未排序好的序列里找出最好的。比如给50人的成绩排序，第一次挑出成绩最高的同学，第二次挑出成绩次高的，如此重复。
- **插入排序**。每一次从已排序好的序列里找到合适的位置插入。比如给50人的成绩排序，先把成绩单第一个位置的同学的成绩写到旁边另一张纸的中央，再在成绩单上往后遍历，如果第二个同学成绩更高，写到第一个同学的上方，否则下方。继续将第三个同学的成绩跟前面两个同学的成绩比较，插入到相应的位置，如此重复，直到成绩单上没有成绩了。当然，白纸要留够空间。


### 计算机一开始使用的排序方法

计算机一开始的排序算法就是基于上述两种：冒泡排序和插入排序。

运用高德纳的思想，可以分析一下冒泡排序和插入排序的算法复杂度：

- 冒泡排序。一开始，从50个人里找出最大的要比较49次（从第一个位置到最后一个位置相邻元素两两比较），找出第二大的要比较48次（上一轮已经找出最大的放在最后一个位置了），以此类推，大约是1200多次，即(50^2)/2左右

- 插入排序。一开始，将第一位同学的成绩插入旁边的白纸，第二位同学在白纸上只需要比较一次（跟第一个位置的同学比较）就可以插入适当的位置，第三位同学需要同前两位比较（在排好序的序列从后向前比较），也就是两次，依次类推，比较次数和冒泡排序差不多。

**如果我们把50扩展到任意一个整数N，两种算法复杂度就都是n^2左右，同属一个量级。**


### 提高排序效率

全世界的算法专家经过十多年，终于发现原因就是冒泡和插入做了无数的无用功。**要提高效率，就是需要让计算机少做事情**。

能让计算机少做事情的算法：

- 归并排序

归并排序使得数据之间的比较次数大幅减少。

如，排序全班同学的成绩，根据归并思想，首先先分成两组，分别排序，再把排好序的两组合并成一个有序的序列（相比排序，**对有序序列合并是很快的**，访问[实现数组合并](http://www.baidu.com)），就能大约省去1/2的比较时间。既然可以分成两组，就能把两个组各自再分成两组，可以省去3/4的比较时间，以此类推，即在各组里递归分组、排序，直到分的小组只有两个人时只要比较一次大小就可以排好序。

归并排序，可以理解为两个过程，**先自顶向下分组，再自底向上合并**。

归并排序的算法复杂度是 nlogn，这个复杂度比n^2要小很多。如当n是100,10000,1000000，它对应的nlogn是700,13万,2000万.而对应的n^2是一万，一亿，一万亿。

归并排序还说明了一个道理，将一个复杂问题分解成多个简单的问题，一个个解决最后比直接解决复杂问题要省很多时间。

- 快速排序

一个算法的好坏要分场景，**理想情况下**最好，还是**一般情况下**最好，又或者**恶劣情况下**最好。

目前时间上一般情况下最好的算法是快速排序算法。

快速排序算法是由英文计算机科学家Tony Hoare于1961年发表的。目前这个算法已经成为世界计算机产业中用到的最多的排序算法。

快速排序的原理：

首先，对于一大堆无序的数字，从中随机挑选一个，比如是53，这个被随机选上的数字被称为枢值（枢纽的枢），接下来，将所有数字分成两部分，第一部分是大于等于枢值53的，第二部分是小于枢值53的，这样一大堆无序的数字就变得稍微有序一点了。第二步，从上面得到的两堆数字，分别采用第一步的方法各自再找一个枢值。对于第一堆，由于所有的数字都比53大，至少也等于53，因此，第二次随机挑选的枢值肯定是一个大于53的数字，比如79；类似地，对于第二堆，由于所有的数字都小于53，因此第二次随机挑选的枢值肯定小于它，比如4。接下来，再把两堆数字各自分成大于等于相应枢值的数字序列，以及小于枢值的数字序列。这样做下来，原来的一大堆数就变成了四小堆，它们分别是小于4的数字，介于4到53之间的，介于53到79之间的，以及大于或等于79的。第三步就是，用同样的方法，四堆变八堆，八堆变十六堆，很快所有的数字就能排好序了。

快速排序的算法复杂度是 nlogn，和归并排序相同。

但是，虽然根据计算机科学的标准，它们同样好，不过**在工程上，快速排序算法在一般情况下比归并排序快两倍**，因此在工程上还是有意义的。

Q：为什么快速排序能更快一些呢？

A：这可以在计算机科学上证明，不过为了方便理解，我打一个比方你就明白了。假如有2000名高中生，要从中挑出尖子，如果是归并排序，就相当于把2000人放到10所学校，每所学校只有200人，再从这10所中挑出尖子，最后再相互排序选出的尖子；如果是快速排序，就相当于先划分数线，根据成绩高低把排前200放到一个学校，200~400放到一个学校，最后1800~2000放到一个学校，即第十所最差，再分别找出学习尖子，最后直接合并选出的尖子，这样工作量最小。

### 总结

- 冒泡是每个人都要公平和和所有人比；
- 归并排序是递归分组后再比；
- 快速排序是根据枢值分组后再比。

所以说，绝对的公平导致效率更低。

### 代码实现

- 冒泡排序

```javascript

function sortFn(arr) {
  for(let i = 0; i < arr.length; i++) {
    for(let j = i+1; j < arr.length; j++) {
      if(arr[i] > arr[j]) {
        //交换位置
        arr[i] = [arr[j], arr[j]=arr[i]][0];
      }
    }
  }
}

```

- 插入排序

```javascript

function sortFn(arr) {
  //前一个值的索引
  let prev = 0;

  let current = 0;

  for(let i=1; i<arr.length; i++){
    //第一个元素可以认为已经被排好序

    prev = i-1;
    current = arr[i];

    //向前遍历比较，如果比当前值大
    while(prev>=0 && current<arr[prev]) {
      arr[prev+1] = arr[prev];  //相邻前一个较大值后移
      prev--;
    }

    //找到了适当的索引prev+1
    arr[prev+1] = current;
  }
}

···

- 快速排序

```javascript

function quickSortFn(arr) {
  if(arr.length < 2) { return arr; }
  
  let i=0, j=arr.length-1;
  //将a[0]作为枢值pivot

  while(i<j) {
    //Q：为什么如果枢值选择数组最左边元素，每次移动必须先从后往前找到比枢值小的数
    //A：在极限情况下不能满足，如[7, 1, 2, 3, 4, 5, 6, 7, 8]

    //先从后往前，找比枢值小的数
    while(i<j && arr[j]>=arr[0]) {
      j--;
    }

    //再从前往后，找比枢值大的数
    while(i<j && arr[i]<=arr[0]) {
      i++;
    }
    
    //当left和right相遇，交换arr[0]和当前两个指针所在位置的元素
    if(i==j) {
      arr[j] = [arr[0], arr[0]=arr[j]][0];
      break;
    }
    
    //当left依然小于right，交换两个指针所在位置的元素
    arr[right] = [arr[left], arr[left]=arr[right]][0];
  }

  return quickSortFn(arr.slice(0, left)).concat(arr.slice(left, right+1)).concat(quickSortFn(arr.slice(right+1)));

}

quickSortFn(arr);

```
