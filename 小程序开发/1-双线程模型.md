



## 一、为什么不直接使用web单线程模型

经常有人问到这样一个问题：“微信小程序与 Web 页面在技术层面的主要区别是什么？”我相信你也有类似的困惑，因为在编程语言和编程习惯上，小程序开发与 Web 前端开发非常相似，比如都用 JavaScript 语言、与 HTML/CSS 非常相似的 WXML/WXSS 等，**可它却没有直接用原生的前端技术**，而是单独自己做了一套。

这个问题的根源在于：**与 Web 网站相比，以微信为宿主的小程序更需要考虑安全、性能等因素，因为要考虑小程序不会对微信产生安全隐患，同时要尽量达到接近原生应用的用户体验**。这也是为什么小程序不直接用浏览器的线程模型，非要自己弄一套双线程模型最主要的两个原因。

## 二、那什么是小程序的双线程模型呢？

要理解这个问题，你先要对浏览器的线程模型有一定的了解，因为理解一个新概念或技术的最好的方法就是给它一个参照物，可以通过阅读[event-loop理解](https://github.com/hoanFir/blogs/blob/master/JavaScript%20%E5%9F%BA%E7%A1%80/event-loop%E7%90%86%E8%A7%A3.md)学习浏览器进程和线程模型。要注意，JavaScript 语言的单线程不能理解为“浏览器单线程”，浏览器内部架构很复杂，只不过在处理 GUI 渲染线程和 JavaScript 逻辑脚本线程上用了互斥、阻塞的管理模式，让一些开发者产生了误解罢了。


以chrome为例，每个标签页就是一个单独的进程，在每个标签页进程中，浏览器会把不同的工作交给对应的线程，比如 GUI 渲染线程负责把 HTML 渲染成可视化的 UI，JavaScript 引擎线程负责解析和运行 JavaScript 代码逻辑，定时触发器线程负责处理 setTimeout/setInterval 定时器等。

> 这里有一个很容易搞混的误区： setTimeout/setInterval 并不是 JavaScript 语言的一部分，而是运行时（最初是浏览器，后来 Node.js 也提供了支持）提供的能力。

接着说回来，其中 GUI 渲染线程和 JavaScript 引擎线程是互斥的，JavaScript 在执行期间会阻塞 UI 的渲染，甚至如果脚本执行时间太长会由于页面长时间无响应然后崩溃，正是 GUI 渲染线程和 JavaScript 引擎线程之间的这种互斥、阻塞的线程管理方式，让一部分前端开发者以为浏览器是单线程的。

> 那为什么 JavaScript 要被设计成单线程的呢？JavaScript 祖师爷只用了 10 天就创造了这门语言，最初他的想法只是在浏览器中提供一些简单的脚本逻辑用来处理用户交互、DOM 操作等，所以从设计上必须遵循两点：语法简单；运行机制简单。在语法上，JavaScript 借鉴了 Java，但是去除了很多复杂的设定，比如类型声明、模块体系等。在运行机制上，JavaScript 并没有像 Java 那样提供多线程能力，最主要就是为了避免多线程操作 DOM 造成 UI 冲突。比如存在多个线程同时操作同一个 DOM，浏览器该如何判断最终的 UI 效果是采用哪个线程的结果？这是经典的线程安全（也称为线程同步）问题，在多线程编程领域有很多解决方案，比如加入锁机制，但这样却又带来了更多的复杂性，与 JavaScript 简单易用的设计初衷相违背。

