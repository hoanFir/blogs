



## 一、为什么不直接使用web单线程模型

经常有人问到这样一个问题：“微信小程序与 Web 页面在技术层面的主要区别是什么？”我相信你也有类似的困惑，因为在编程语言和编程习惯上，小程序开发与 Web 前端开发非常相似，比如都用 JavaScript 语言、与 HTML/CSS 非常相似的 WXML/WXSS 等，**可它却没有直接用原生的前端技术**，而是单独自己做了一套。

这个问题的根源在于：**与 Web 网站相比，以微信为宿主的小程序更需要考虑安全、性能等因素，因为要考虑小程序不会对微信产生安全隐患，同时要尽量达到接近原生应用的用户体验**。这也是为什么小程序不直接用浏览器的线程模型，非要自己弄一套双线程模型最主要的两个原因。

## 二、那什么是小程序的双线程模型呢？

### 2.1 浏览器进程和线程模型

要理解这个问题，你先要对浏览器的线程模型有一定的了解，因为理解一个新概念或技术的最好的方法就是给它一个参照物，可以通过阅读[event-loop理解](https://github.com/hoanFir/blogs/blob/master/JavaScript%20%E5%9F%BA%E7%A1%80/event-loop%E7%90%86%E8%A7%A3.md)学习浏览器进程和线程模型。要注意，JavaScript 语言的单线程不能理解为“浏览器单线程”，浏览器内部架构很复杂，只不过在处理 GUI 渲染线程和 JavaScript 逻辑脚本线程上用了互斥、阻塞的管理模式，让一些开发者产生了误解罢了。

以chrome为例，每个标签页就是一个单独的进程，在每个标签页进程中，浏览器会把不同的工作交给对应的线程，比如 GUI 渲染线程负责把 HTML 渲染成可视化的 UI，JavaScript 引擎线程负责解析和运行 JavaScript 代码逻辑，定时触发器线程负责处理 setTimeout/setInterval 定时器等。

> 这里有一个很容易搞混的误区： setTimeout/setInterval 并不是 JavaScript 语言的一部分，而是运行时（最初是浏览器，后来 Node.js 也提供了支持）提供的能力。

接着说回来，其中 GUI 渲染线程和 JavaScript 引擎线程是互斥的，JavaScript 在执行期间会阻塞 UI 的渲染，甚至如果脚本执行时间太长会由于页面长时间无响应然后崩溃，正是 GUI 渲染线程和 JavaScript 引擎线程之间的这种互斥、阻塞的线程管理方式，让一部分前端开发者以为浏览器是单线程的。

> 那为什么 JavaScript 要被设计成单线程的呢？JavaScript 祖师爷只用了 10 天就创造了这门语言，最初他的想法只是在浏览器中提供一些简单的脚本逻辑用来处理用户交互、DOM 操作等，所以从设计上必须遵循两点：语法简单；运行机制简单。在语法上，JavaScript 借鉴了 Java，但是去除了很多复杂的设定，比如类型声明、模块体系等。在运行机制上，JavaScript 并没有像 Java 那样提供多线程能力，最主要就是为了避免多线程操作 DOM 造成 UI 冲突，JavaScript 代码有修改 DOM 的权限。比如存在多个线程同时操作同一个 DOM，浏览器该如何判断最终的 UI 效果是采用哪个线程的结果？这是经典的线程安全（也称为线程同步）问题，在多线程编程领域有很多解决方案，比如加入锁机制，但这样却又带来了更多的复杂性，与 JavaScript 简单易用的设计初衷相违背。

顺便说一下，浏览器的空闲（Idle）时长代表JavaScript逻辑不密集以及DOM改动频率低，因此也成为了衡量网站性能的重要指标之一，这种情况下浏览器可以更快速顺畅地响应用户的交互行为。

### 2.2 html5 web worker

想要认识小程序的双线程模型，还要了解一个概念，web worker。

HTML5 引入了 Web Worker，提供多线程执行JavaScript代码的能力，但Worker线程和主线程是一种主从（master- slave）多线程模型，即Worker内的JavaScript不能操作DOM，所以可以将其理解为**线程安全**。安全，正是微信想要的。

### 2.3 为什么小程序不使用浏览器的线程模型

要从产品和技术两个角度对比小程序和web网站的差异。

小程序的宿主是微信，但是小程序版本迭代是独立的，升级更新不依赖宿主，这一点跟web网站是相同的，也就是说，小程序沿袭了web的某些优势。但是，小程序的定位是小而美、用完即走，因此不追求在微信中实现全部的web能力，并且能具备微信生态提供的能力。

从技术角度上，小程序与微信的关系有点类似CodePen这类在线编程平台中每个程序案例与平台的关系。平台最核心的一个考量点是为案例提供足够能力的前提下，保证案例的逻辑不会危及平台的安全。以 CodePen 为例，假如让你来设计这样的编程平台，你会用什么技术呢？ 可能你第一个想到的是用 iframe，因为你可以在 iframe 内使用全部 Web 能力。事实上 CodePen 确实用 iframe 来呈现程序的效果，但是并不会把你输入的 JavaScript 代码完全拷贝到 iframe 内运行，而是代码会经过一次编译流程之后才会被注入 iframe 内。这样做的出发点之一是基于安全的考虑，在编译过程中将一些危险的代码剔除。所以，你不能直接使用 iframe，而是需要引入额外的 JavaScript 编译器。CodePen 一定要保证每个案例的 JavaScript 代码是线程安全的，最基本的就是要禁止程序操作 CodePen 网站的 DOM ，如何实现这一点呢？你有两个方法：

- 使用 Web Worker

Web Worker 是线程安全的，Worker 内的 JavaScript 代码无法获取 Window 和 Document 对象，也就无法操作 DOM。除此之外，由于 Worker 的线程安全特性，Worker 内的代码运行过程中不会阻塞外层的 GUI 渲染线程，两者可以并行。

- 使用 Shadow DOM

而 Shadow DOM 是 Web Components 规范的一部分，将 ShadowRoot 的模式设置为 closed 就可以禁止获取到 ShadowRoot 节点，从而也无法操作其内部的 DOM。

不过，你要注意， Shadow DOM 的兼容性比 Web Worker 更差，距大规模使用的日期还很遥远，所以 Web Worker 的方案更现实一点。

这样就形成了一个简易的双线程模型：Worker 线程负责计算，将结果通过 postMessage 传递给主线程，主线程负责渲染。但是这个模型存在比较严重的性能问题，Web Worker 非常耗费资源，除去计算消耗以外，与主线程的通信过程对性能的损耗也非常严重。

**那有没有办法实现跟 Web Worker 一样的线程安全，同时又兼顾性能保证良好的用户体验呢？这便是微信小程序采用双线程模型的主要目的。**

### 2.4 安全高效的小程序双线程模型

- 限制 UI 组件类型，只允许声明指定的几个组件

小程序并不需要支持所有的 HTML 标签，只提供有限的几类 UI 组件，小程序在声明组件时并不是使用原生的 HTML 标签，而是只能够通过微信提供的几种内置基础组件，当然你也可以自定义组件，但也是通过对内置基础组件的组合来实现。

- 保证逻辑线程安全，不允许直接操作 UI 组件

小程序更新 UI 的方式与 Vue/React 等 MVVM 框架类似，JavaScript 代码不能直接操作 DOM，而是通过更新状态（ setState ）的方式异步更新 UI ，这个过程中会用到 VDOM 和高效的 diff 算法。

- 能够在线更新，不依赖微信

小程序的宿主是微信，如果使用纯 Native 实现，那么小程序的版本更新必须依赖微信，跟微信的代码一起发版，这样肯定是不行的。如果是纯 Web 实现，安全和性能就很难得到保障。

因此，小程序需要既能够像 Web 一样将资源托管在云端，更新独立；同时又能够保证足够好的安全性和性能。**所以最终小程序采用了 Hybrid-混合的架构模式：使用 Webview 渲染 UI、使用类似 Web Worker 的独立线程运行逻辑，这就是接下来要讲的双线程模型。**

- 性能需尽量提升，保证用户体验

前面提到的基于 Web Worker 的简易双线程模型性能是很大的问题，因此小程序的双线程模型并不是使用 Web Worker 子线程，而是一个独立的“主线程”，这样能够保证相对较好的性能。


最终设计出来的渲染层和逻辑层：

![](https://res.wx.qq.com/wxdoc/dist/assets/img/4-1.ad156d1c.png)

如图所示，渲染线程使用 Webview 进行 UI 的渲染呈现。Webview 是一个完整的类浏览器运行环境，本身具备运行 JavaScript 的能力，但是小程序并不是将逻辑脚本放到 Webview 中运行，而是将逻辑层独立为一个与 Webview 平行的线程，使用客户端提供的 JavaScript 引擎运行代码，iOS 的 JavaScriptCore、安卓是腾讯 X5 内核提供的 JsCore 环境以及 IDE 工具的 nwjs 。并且逻辑线程是一个只能够运行 JavaScript 的沙箱环境，不提供 DOM 操作相关的 API，所以不能直接操作 UI，只能够通过 setData 更新数据的方式异步更新 UI。

要注意上图渲染线程和逻辑线程之间的通信方式，与 Vue/React 不同的是，小程序的渲染层与逻辑层之间的通信并不是在两者之间直接传递数据或事件，而是由 Native 作为中间媒介进行转发。整个过程是典型的事件驱动模式：

- 渲染层通过与用户的交互触发特定的事件 event；
- 然后 event 被传递给逻辑层；
- 逻辑层继而通过一系列的逻辑处理、数据请求、接口调用等行为将加工好的数据 data 传递给渲染层；
- 最后渲染层将 data 渲染为可视化的 UI；

这种数据驱动 UI 的模式是近几年前端编程领域较为推崇的编程范式。

而这样逻辑与渲染分离的线程分工模式一方面能够保证运行在逻辑线程沙箱内的 JavaScript 代码是线程安全的，另一方面由于渲染线程的计算量非常小从而保证了对用户交互行为的快速响应，提高了用户体验。

总的来说，跟浏览器的线程模型相比，小程序的双线程模型解决了或者说规避了 Web Worker 堪忧的性能同时又实现了与 Web Worker 相同的线程安全，从性能和安全两个角度实现了提升。可以概括地说，双线程模式是受限于浏览器现有的进程和线程管理模式之下，在小程序这一具体场景之内的一种改进的架构方案。
