
位操作符，作用于最基本的层次，即按内存中表示数值的位来操作数值。

ECMAScript 中所有数值，都以 IEEE-754 64 位格式存储。

Javascript 的位操作符，并不直接操作 64 位的值，而是先将 64 位 的值转换成 32 位的整数，然后执行操作，最后再将结果转换回 64 位。

对于开发人员来说，由于 64 位存储格式是透明的，因此整个过程就像是只存在 32 位的整数一样。


### 一、有符号整数

对于有符号整数，32 位中的前 31 位 用于表示整数的值，第 32 位 表示数值的符号，0 表示正数，1 表示负数。

对于正数，以纯二进制格式存储，例如 18 的二进制表示是 00000000000000000000000000010010，或者 10010，这 5 位是有效位。

对于负数，以其绝对值的二进制补码格式存储，即首先需要求指定数值的绝对值的二进制码，再求二进制反码（将0变为1，将1变为0），最后将得到对二进制反码加1。例如 -18 对二进制表示是 11111111111111111111111111101110。

注意，ECMAScript 会对开发者隐藏这些信息，也就是说在以二进制字符串输出一个负数时，会以更合乎逻辑的形式展示出来，如下：

```

num = -18
num.toString(2) = -10010

```


### 二、无符号整数

默认情况下，ECMAScript 中所有整数都是有符号整数，但也存在无符号整数。

对于无符号整数，只能为正数，因为第 32 位不再表示符号。


### 三、位操作-按位非-NOT

由 `~` 表示，结果就是指定数值二进制反码。按位非但本质是：操作数的负值减1。

```javascript

var num1 = 25; //11001
var num2 = ~num1; //11111111111111111111111111100110 = -26
var num3 = -num1-1; //-26

按位非执行速度更快...

```


### 四、位操作-按位与-AND

由 `&` 表示，二进制格式中同时为 1 结果才为 1。

```javascript

var num = 25 & 3;

25 = 00000000000000000000000000011001
 3 = 00000000000000000000000000000011
num= 00000000000000000000000000000001

num = 1

```


### 五、位操作-按位或-OR

由 `|` 表示，二进制格式中有一个为 1 结果就为 1。

```javascript

var num = 25 ｜ 3;

25 = 00000000000000000000000000011001
 3 = 00000000000000000000000000000011
num= 00000000000000000000000000011011

num = 27

```



### 六、位操作-按位异或-XOR

由 `^` 表示，二进制格式中一个为 1且另一个为 0 结果才为 1。

```javascript

var num = 25 ^ 3;

25 = 00000000000000000000000000011001
 3 = 00000000000000000000000000000011
num= 00000000000000000000000000011010

num = 26

注意，比按位或的结果小1...

```

### 七、位操作-左移-<<

由 `<<` 表示，将指定数值的二进制格式中所有位向左移动指定位数。左移操作会以 0 来填充空位，以便结果是一个完整的 32 位二进制数。

注意，左移不会影响符号位。

```javascript

var num = 2;
var res = num << 5;

2 = 10
num << 5 = 1000000

res = 64

```

### 八、位操作-右移

**1. 有符号右移**

由 `>>` 表示，将指定数值的二进制格式中所有位向右移动指定位数。右移操作会以符号位来填充空位，以便结果是一个完整的 32 位二进制数。

注意，有符号的右移不会影响符号位。

```javascript

var num = 64;
var res = num >> 5;

64 = 1000000
num << 5 = 10

res = 2

```


**2. 无符号右移**

由 `>>>` 表示。

对于正数，无符号右移的结果与有符号右移相同。

但对于负数：

1) 由于无符号右移以 0 来填充空位，因此结果和有符号右移（以符号位填充）是不同的

2) 无符号右移会把负数的二进制码当成正数的二进制码，由于负数以其绝对值的二进制补码的形式表示，因此会导致无符号右移后的结果非常大

```javascript

-64 >>> 5

-64 = 11111111111111111111111111000000

将 -64 的二进制码当成正数的二进制码，等于十进制的 4292967232，再进行右移

64 >>> 5 = 0000011111111111111111111111110

等于十进制的 134217726
 

```










