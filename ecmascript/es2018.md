
```

ECMAScript 版本提案：

strawman(最初想法的提交)、

proposal(由技术委员会至少一名成员倡导的正式提案文件)、

draft(功能规范的初始版本草案)、

candidate(提案规范通过审查并从厂商那收集反馈)、

finished(提案准备加入ECMAScript，但浏览器或nodejs实现还不一定)

```


### 一、asynchronous iteration

在 ECMAScript 2018 之前，当开发者使用 asynchronous function inside a synchronous loop：

```javascript

async function process (array) {
  for(let i of array) {
    await doSomething(i);
  }
}

```

上述代码存在的问题：遍历依旧保持同步，且总是在内部异步操作之前就结束，导致不会正常运行。

在 ECMAScript 2018 之后：

```javascript

async function process (array) {
  for await(let i of array) {
    doSomething(i);
  }
}
```


### 二、Promise.finally()

在 ECMAScript 2018 之前，对于 Promise chain，要么成功触发 then，要么失败触发 catch。但开发者还想要，不管是执行成功或失败，都要执行一些其他相同的处理。比如 to clean up/remove a dialog，close a database connection...

```javascript

function do() {
  test()
    .then(data1)
    .then(data2)
    .catch(err => { console.log(err); })
    finally(() => { //finish... })
}

```


### 三、Rest/Spread(...)

在 ECMAScript 2015，引入了 rest parameters 和 spread operators：

```javascript

//1
//rest parameters
//convert the last arguments passed to a function (into an array)

function restParams(p1, p2, ...p3) {
  //...
}

restParams(1, 3, 5, 7, 9);
//p1 === 1
//p2 === 3
//p3 === [5, 7, 9]



//2
//spread operators
//turns an array into separate arguments which can be passed to a function

const values = [99, 100, -1, 48];
Math.max(...values); === Math.max(99, 100, -1, 48);

```

注意：

3.1 rest 只能在参数的结尾处使用
3.2 rest 只适用于对象的顶层，不适用于嵌套对象


### 四、SharedArrayBuffer/atomics

The main idea is to bring some sort of multi-threading feature to JavaScript so that JS developers can write high-performance, concurrent programs in the future by allowing to manage memory by themselves instead of letting JS engine manage memory.

This is done by a new type of a global object called SharedArrayBuffer that essentially stores data in a shared memory space. So this data can be shared between **the main JS thread** and **web-worker threads**.

在 ECMAScript 2018 之前，如果想要在 the main JS thread 和 web-workers 之间访问同一数据，就必须 copay the data and send it to the other thread using `post Message`。

现在，developers simply use SharedArrayBuffer and the data is instantly accessible by both the main thread and multiple web-worker threads.

But sharing memory between threads can cause race conditions. To help avoid race conditions, the “Atomics” global object is introduced. Atomics provides various methods to lock the shared memory when a thread is using its data. It also provides methods to update such data in that shared memory safely.


