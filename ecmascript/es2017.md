
```

ECMAScript ç‰ˆæœ¬ææ¡ˆï¼š

strawman(æœ€åˆæƒ³æ³•çš„æäº¤)ã€

proposal(ç”±æŠ€æœ¯å§”å‘˜ä¼šè‡³å°‘ä¸€åæˆå‘˜å€¡å¯¼çš„æ­£å¼ææ¡ˆæ–‡ä»¶)ã€

draft(åŠŸèƒ½è§„èŒƒçš„åˆå§‹ç‰ˆæœ¬è‰æ¡ˆ)ã€

candidate(ææ¡ˆè§„èŒƒé€šè¿‡å®¡æŸ¥å¹¶ä»å‚å•†é‚£æ”¶é›†åé¦ˆ)ã€

finished(ææ¡ˆå‡†å¤‡åŠ å…¥ECMAScriptï¼Œä½†æµè§ˆå™¨æˆ–nodejså®ç°è¿˜ä¸ä¸€å®š)

```


### ä¸€ã€Object.values()

Object.values is similar to Object.keys() but returns all the values of the Object's own properties excluding any values in the prototypical chain.

åœ¨ ECMAScript 2017 ä¹‹å‰ï¼Œè·å–å¯¹è±¡å±æ€§çš„å€¼å¯ä»¥ä½¿ç”¨ Object.keys()ï¼Œä½†è¿”å›çš„æ˜¯å±æ€§åï¼Œå› æ­¤è¿˜éœ€è¦é…åˆ map æ–¹æ³•æ¥è·å–ã€‚

```javascript

const peos = {
  name: 1,
  age: 18
}

const vals = Object.keys(peos).map(key => peos[key]);
[1, 18]

const values = Object.values(peos);
[1, 18]

```


### äºŒã€Object.entries()

to returns both keys and values in the array.

This makes it very simple to do things like using objects in loops or converting objects into Maps.

åœ¨ ECMAScript 2017 ä¹‹å‰ï¼Œè·å–å¹¶æ“ä½œå¯¹è±¡å±æ€§å€¼å¯¹å¯ä»¥ä½¿ç”¨ Object.keys() é…åˆ forEach æ–¹æ³•æ¥éå†ã€‚

```javascript

//1 loop

const peos = {
  name: 1,
  age: 18
}

Object.keys(peos).forEach(key => {
  peos[key]...
});

for(let [key, value] of Object.entries(peos)) {
  key...value...
}
Object.entries(peos).map(([key, value]) => {})


//2 Map

const peos = {
  name: 1,
  age: 18
}
const map1 = new Map();

Object.keys(peos).forEach(key => {
  map1.set(key, peos[key]);
});
map1 === Map(2) { 'name' => 1, 'age' => 18 }


const map2 = new Map(Object.entries(peos));
map2 === Map(2) { 'name' => 1, 'age' => 18 }

```


### ä¸‰ã€String padding

`String.prototype.padStart` and `String.prototype.padEnd`.

Allow appending/prepending either an empty string or some other string to the start or the end of the original string.

å½“æƒ³è¦åœ¨æ‰“å°åœºæ™¯ä¸­å¯¹é½æ—¶ï¼Œè¿™å°±æ´¾ä¸Šç”¨åœºäº†ã€‚

```javascript

'someString'.padStart(numberOfCharcters [,stringForPadding]); 

//1

'5'.padStart(10) // '          5'
'5'.padStart(10, '0') //"0000000005"
'12'.padStart(10, '0') //"0000000015"


//2

'5'.padEnd(10) // '5         '
const cars = {
  'BMW': '10',
  'Tesla': '5',
}
Object.entries(cars).map(([name, count]) => {
  console.log(`${name.padEnd(20, ' -')} Count: ${count.padStart(3, '0')}`)
})

BMW - - - - - - - Count: 010
Tesla - - - - - - Count: 005

```

### å››ã€Object.getOwnPropertyDescriptors()

returns all the details for all the properties of a given object.

å¯¹è±¡å±æ€§æœ‰ä¸¤ç§ç±»å‹ï¼šæ•°æ®å±æ€§å’Œè®¿é—®å™¨å±æ€§ã€‚ä»–ä»¬æ‰€æ‹¥æœ‰çš„ç‰¹æ€§ä¸æ˜¯å®Œå…¨ä¸€è‡´çš„ã€‚æ¯”å¦‚è®¿é—®å™¨å±æ€§æ²¡æœ‰ `value`ï¼Œæœ‰ `getter` å’Œ `setter`ã€‚

The `Object.getOwnPropertyDescriptor()` method returns a property descriptor for an own property (that is, one directly present on an object and not in the object's prototype chain) of a given object.

ä¸ºä»€ä¹ˆè¦å¼•å…¥è¿™ä¸ªï¼Ÿåœ¨ ECMAScript 2017 ä¹‹å‰ï¼Œæµ…å¤åˆ¶ä¸€ä¸ªå¯¹è±¡å¯ä»¥ä½¿ç”¨ Object.assignï¼Œä½†æ˜¯è¿™ä¸ªæ–¹æ³•ä¸ä¼šå¤åˆ¶ `getter` and `setter` functions. åœ¨ ECMAScript 2017 ä¹‹åï¼Œå¯ä»¥ä½¿ç”¨`Object.defineProperties({}, Object.getOwnPropertyDescriptor(Obj))`æ¥å®Œæˆæ‹·è´ã€‚

```javascript

//1

let Car = {
  name: 'BMW',
  price: 100,
  set discount(x) {
    this.d = x;
  }
  get discount() {
    retrun this.d;
  },
}

//æ‰“å° discount è®¿é—®å™¨å±æ€§ä¿¡æ¯
Object.getOwnPropertyDescriptor(Car, 'discount'));
{
  get: [Function: get],
  set: [Function: set],
  enumerable: true,
  configurable: true,
}

//å¤åˆ¶
const copyCar = Object.assign({}, Car);
Object.getOwnPropertyDescriptor(copyCar, 'discount'));
{
  value: undefined,
  writable: true,
  enumerable: true,
  configurable: true,
}


//2

let Car = {
  name: 'BMW',
  price: 100,
  set discount(x) {
    this.d = x;
  }
  get discount() {
    retrun this.d;
  },
}

//å¤åˆ¶
const copyCar = Object.defineProperties({}, Object.getOwnPropertyDescriptor(Car));

```

### äº”ã€å‡½æ•°å‚æ•°åˆ—è¡¨ç»“å°¾å…è®¸é€—å·

to help with tools like git blame to ensure only new developers get blamed.

åœ¨ ECMAScript 2017 ä¹‹å‰ï¼Œè¦å¯¹ä¸€ä¸ªå·²æœ‰å‡½æ•°è¿›è¡Œæ‰©å±•ï¼Œæ¯”å¦‚å¢åŠ å‚æ•°ï¼Œå¦‚ä»£ç ï¼š

```javascript

//developer #1
function test (
  name, 
  age
  ){
    ...
}

//developer #2
function test (
  name, 
  age,
  job
  ){
    ...
}

```

åœ¨ä¸Šè¿°ä»£ç ä¸­ï¼Œä¿®æ”¹åçš„ä»£ç åœ¨ç”¨å¦‚ git ç­‰å·¥å…·æäº¤åˆ°è¿œç¨‹ä»“åº“æ—¶ï¼Œ`age` è¿™ä¸€è¡Œä»£ç ä¹Ÿä¼šè¢«æ ‡è®°ä¸º `update`ï¼Œä½†å…¶è·Ÿå½“å‰ commit çš„ç¨‹åºå‘˜å…¶å®æ˜¯æ— å…³çš„ã€‚

å› æ­¤ï¼Œæ¨èåœ¨å‡½æ•°æœ€åä¸€ä¸ªå‚æ•°ååŠ ä¸Šé€—å·ã€‚

```javascript

//developer #1
function test (
  name, 
  age,
  ){
    ...
}

//developer #2
function test (
  name, 
  age,
  job
  ){
    ...
}

```


### å…­ã€async/await ğŸŒŸğŸŒŸğŸŒŸ

åœ¨ ECMAScript 2017 ä¹‹å‰ï¼Œå¯¹äºå¼‚æ­¥å®ç°ï¼Œä¸»è¦ä½¿ç”¨ Promise æˆ– callbackã€‚ç†è§£è¿™ä¸‰è€…ä¹‹é—´çš„å‘å±•å’Œå¼‚åŒå°¤ä¸ºé‡è¦ã€‚

An async function is a function declared with the async keyword. Async functions are instances of the `AsyncFunction constructor`.

Async functions allows developers to not deal with callback hell and make the entire code look simple.

The `async` keyword tells the javascript compiler to treat the funciton differently. The compiler pauses/suspend whenever it reaches the `await` keyword within that function, and yielding control and subsequently resuming(ç»§ç»­) progress only when an awaited promise-based asynchronous operation is either fulfilled or reject.

```javascript

function getUser(userId) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve('test');
    }, 1000);
  });
}

function getBankBalance(user) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if(ueser == 'test') {
        resolve('ok');
      } else {
        reject('unknown user...');
      }
    }, 1000);
  });
}


//1

function getAmount1(userId) {
  getUser(userId)
    .then(getBankBalance)
    .then(amount => {
      ...
    });
}

//2

async function getAmount2(userId) {
  var user = await getUser(userId);
  var amount = await getBankBalance(user);
  
  ...
}

```


å¦å¤–æ³¨æ„ï¼ŒAsync functions themselves return a Promise

```javascript

//1
//Async functions themselves return a Promise
async function doubleAndAdd(a, b) {
  a = await doubleAfterSec(a);
  b = await doubleAfterSec(b); 
  return a+b;
}
doubleAndAdd(1, 2).then();


//2
//If the return value of an async function is not explicitly a promise, it will be implicitly wrapped in a promise.
async function foo() {
  return 1;
}
===
function foo() {
  return Promise.resolve(1);
}

foo.then();


//3
//code after each await expression can be thought of as existing in a .then callback
async function foo() {
  await 1;
}
===
function foo() {
  return Promise.resolve(1).then(() => undefined);
}

foo();
```


## why to use 

The async and await keywords enable asynchronous, promise-based behavior to be written in a cleaner style, avoiding the need to explicitly configure promise chains.

And use of async/await enables the use of ordinary try/catch blocks around asynchronous code. å› ä¸º try/catch ä¸é€‚ç”¨äºå¼‚æ­¥ï¼Œè€Œ async/await ä»¥åŒæ­¥å½¢å¼ç¼–ç ã€‚




