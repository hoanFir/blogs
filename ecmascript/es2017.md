
```

ECMAScript ÁâàÊú¨ÊèêÊ°àÔºö

strawman(ÊúÄÂàùÊÉ≥Ê≥ïÁöÑÊèê‰∫§)„ÄÅ

proposal(Áî±ÊäÄÊúØÂßîÂëò‰ºöËá≥Â∞ë‰∏ÄÂêçÊàêÂëòÂÄ°ÂØºÁöÑÊ≠£ÂºèÊèêÊ°àÊñá‰ª∂)„ÄÅ

draft(ÂäüËÉΩËßÑËåÉÁöÑÂàùÂßãÁâàÊú¨ËçâÊ°à)„ÄÅ

candidate(ÊèêÊ°àËßÑËåÉÈÄöËøáÂÆ°Êü•Âπ∂‰ªéÂéÇÂïÜÈÇ£Êî∂ÈõÜÂèçÈ¶à)„ÄÅ

finished(ÊèêÊ°àÂáÜÂ§áÂä†ÂÖ•ECMAScriptÔºå‰ΩÜÊµèËßàÂô®ÊàñnodejsÂÆûÁé∞Ëøò‰∏ç‰∏ÄÂÆö)

```


### ‰∏Ä„ÄÅObject.values()

Object.values is similar to Object.keys() but returns all the values of the Object's own properties excluding any values in the prototypical chain.

Âú® ECMAScript 2017 ‰πãÂâçÔºåËé∑ÂèñÂØπË±°Â±ûÊÄßÁöÑÂÄºÂèØ‰ª•‰ΩøÁî® Object.keys()Ôºå‰ΩÜËøîÂõûÁöÑÊòØÂ±ûÊÄßÂêçÔºåÂõ†Ê≠§ËøòÈúÄË¶ÅÈÖçÂêà map ÊñπÊ≥ïÊù•Ëé∑Âèñ„ÄÇ

```javascript

const peos = {
  name: 1,
  age: 18
}

const vals = Object.keys(peos).map(key => peos[key]);
[1, 18]

const values = Object.values(peos);
[1, 18]

```


### ‰∫å„ÄÅObject.entries()

to returns both keys and values in the array.

This makes it very simple to do things like using objects in loops or converting objects into Maps.

Âú® ECMAScript 2017 ‰πãÂâçÔºåËé∑ÂèñÂπ∂Êìç‰ΩúÂØπË±°Â±ûÊÄßÂÄºÂØπÂèØ‰ª•‰ΩøÁî® Object.keys() ÈÖçÂêà forEach ÊñπÊ≥ïÊù•ÈÅçÂéÜ„ÄÇ

```javascript

//1 loop

const peos = {
  name: 1,
  age: 18
}

Object.keys(peos).forEach(key => {
  peos[key]...
});

for(let [key, value] of Object.entries(peos)) {
  key...value...
}
Object.entries(peos).map(([key, value]) => {})


//2 Map

const peos = {
  name: 1,
  age: 18
}
const map1 = new Map();

Object.keys(peos).forEach(key => {
  map1.set(key, peos[key]);
});
map1 === Map(2) { 'name' => 1, 'age' => 18 }


const map2 = new Map(Object.entries(peos));
map2 === Map(2) { 'name' => 1, 'age' => 18 }

```


### ‰∏â„ÄÅString padding

`String.prototype.padStart` and `String.prototype.padEnd`.

Allow appending/prepending either an empty string or some other string to the start or the end of the original string.

ÂΩìÊÉ≥Ë¶ÅÂú®ÊâìÂç∞Âú∫ÊôØ‰∏≠ÂØπÈΩêÊó∂ÔºåËøôÂ∞±Ê¥æ‰∏äÁî®Âú∫‰∫Ü„ÄÇ

```javascript

'someString'.padStart(numberOfCharcters [,stringForPadding]); 

//1

'5'.padStart(10) // '          5'
'5'.padStart(10, '0') //"0000000005"
'12'.padStart(10, '0') //"0000000015"


//2

'5'.padEnd(10) // '5         '
const cars = {
  'BMW': '10',
  'Tesla': '5',
}
Object.entries(cars).map(([name, count]) => {
  console.log(`${name.padEnd(20, ' -')} Count: ${count.padStart(3, '0')}`)
})

BMW - - - - - - - Count: 010
Tesla - - - - - - Count: 005

```

### Âõõ„ÄÅObject.getOwnPropertyDescriptors()

returns all the details for all the properties of a given object.

ÂØπË±°Â±ûÊÄßÊúâ‰∏§ÁßçÁ±ªÂûãÔºöÊï∞ÊçÆÂ±ûÊÄßÂíåËÆøÈóÆÂô®Â±ûÊÄß„ÄÇ‰ªñ‰ª¨ÊâÄÊã•ÊúâÁöÑÁâπÊÄß‰∏çÊòØÂÆåÂÖ®‰∏ÄËá¥ÁöÑ„ÄÇÊØîÂ¶ÇËÆøÈóÆÂô®Â±ûÊÄßÊ≤°Êúâ `value`ÔºåÊúâ `getter` Âíå `setter`„ÄÇ

‰∏∫‰ªÄ‰πàË¶ÅÂºïÂÖ•Ëøô‰∏™Ôºü

Âú® ECMAScript 2017 ‰πãÂâçÔºåÊµÖÂ§çÂà∂‰∏Ä‰∏™ÂØπË±°ÂèØ‰ª•‰ΩøÁî® Object.assignÔºå‰ΩÜÊòØËøô‰∏™ÊñπÊ≥ï‰∏ç‰ºöÂ§çÂà∂ `getter` and `setter` functions.

```javascript

//1

let Car = {
  name: 'BMW',
  price: 100,
  set discount(x) {
    this.d = x;
  }
  get discount() {
    retrun this.d;
  },
}

//ÊâìÂç∞ discount ËÆøÈóÆÂô®Â±ûÊÄß‰ø°ÊÅØ
Object.getOwnPropertyDescriptor(Car, 'discount'));
{
  get: [Function: get],
  set: [Function: set],
  enumerable: true,
  configurable: true,
}

//Â§çÂà∂
const copyCar = Object.assign({}, Car);
Object.getOwnPropertyDescriptor(copyCar, 'discount'));
{
  value: undefined,
  writable: true,
  enumerable: true,
  configurable: true,
}


//2

let Car = {
  name: 'BMW',
  price: 100,
  set discount(x) {
    this.d = x;
  }
  get discount() {
    retrun this.d;
  },
}

//Â§çÂà∂
const copyCar = Object.defineProperties({}, Object.getOwnPropertyDescriptor(Car));

```

### ‰∫î„ÄÅÂáΩÊï∞ÂèÇÊï∞ÂàóË°®ÁªìÂ∞æÂÖÅËÆ∏ÈÄóÂè∑

to help with tools like git blame to ensure only new developers get blamed.

Âú® ECMAScript 2017 ‰πãÂâçÔºåË¶ÅÂØπ‰∏Ä‰∏™Â∑≤ÊúâÂáΩÊï∞ËøõË°åÊâ©Â±ïÔºåÊØîÂ¶ÇÂ¢ûÂä†ÂèÇÊï∞ÔºåÂ¶Ç‰ª£Á†ÅÔºö

```javascript

//developer #1
function test (
  name, 
  age
  ){
    ...
}

//developer #2
function test (
  name, 
  age,
  job
  ){
    ...
}

```

Âú®‰∏äËø∞‰ª£Á†Å‰∏≠Ôºå‰øÆÊîπÂêéÁöÑ‰ª£Á†ÅÂú®Áî®Â¶Ç git Á≠âÂ∑•ÂÖ∑Êèê‰∫§Âà∞ËøúÁ®ã‰ªìÂ∫ìÊó∂Ôºå`age` Ëøô‰∏ÄË°å‰ª£Á†Å‰πü‰ºöË¢´Ê†áËÆ∞‰∏∫ `update`Ôºå‰ΩÜÂÖ∂Ë∑üÂΩìÂâç commit ÁöÑÁ®ãÂ∫èÂëòÂÖ∂ÂÆûÊòØÊó†ÂÖ≥ÁöÑ„ÄÇ

Âõ†Ê≠§ÔºåÊé®ËçêÂú®ÂáΩÊï∞ÊúÄÂêé‰∏Ä‰∏™ÂèÇÊï∞ÂêéÂä†‰∏äÈÄóÂè∑„ÄÇ

```javascript

//developer #1
function test (
  name, 
  age,
  ){
    ...
}

//developer #2
function test (
  name, 
  age,
  job
  ){
    ...
}

```


### ÂÖ≠„ÄÅasync/await üåüüåüüåü

Async functions allows developers to not deal with callback hell and make the entire code look simple.

The `async` keyword tells the javascript compiler to treat the funciton differently. The compiler pauses whenever it reaches the `await` keyword within that function.

The expressin after `await` will returns a promise, and waits until the promise is resolved or rejected.

Âú® ECMAScript 2017 ‰πãÂâçÔºåÂØπ‰∫éÂºÇÊ≠•ÔºåÂèØ‰ª•‰ΩøÁî® Promise Êàñ callback„ÄÇÁêÜËß£Ëøô‰∏âËÄÖ‰πãÈó¥ÁöÑÂèëÂ±ïÂíåÂºÇÂêåÂ∞§‰∏∫ÈáçË¶Å„ÄÇ

```javascript

function getUser(userId) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve('test');
    }, 1000);
  });
}

function getBankBalance(user) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if(ueser == 'test') {
        resolve('ok');
      } else {
        reject('unknown user...');
      }
    }, 1000);
  });
}


//1

function getAmount1(userId) {
  getUser(userId)
    .then(getBankBalance)
    .then(amount => {
      ...
    });
}

//2

async function getAmount2(userId) {
  var user = await getUser(userId);
  var amount = await getBankBalance(user);
  
  ...
}

```

Âè¶Â§ñÊ≥®ÊÑèÔºåAsync functions themselves return a Promise„ÄÇ

```javascript

//Async functions themselves return a Promise
async function doubleAndAdd(a, b) {

  a = await doubleAfterSec(a);
  b = await doubleAfterSec(b);
  
  return a+b;
}

doubleAndAdd(1, 2).then(console.log);

```





