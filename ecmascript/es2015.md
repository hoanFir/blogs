
```
ECMAScript 版本提案：

strawman(最初想法的提交)、

proposal(由技术委员会至少一名成员倡导的正式提案文件)、

draft(功能规范的初始版本草案)、

candidate(提案规范通过审查并从厂商那收集反馈)、

finished(提案准备加入ECMAScript，但浏览器或nodejs实现还不一定)

```

### 一、Arrows

Arrows are a function shorthand using the `=>` syntax.

Arrows share the same lexical `this` as their surrounding code. So if an  arrow is inside another function, it shares the "arguments" variable of its parent function.

也就是说，箭头函数本身没有 `this`，其继承所处的外部函数。


```javascript

//1
//expression bodies
var odds = evens.map(v => v+1);
var nums = evens.map((v, i) => v + i);

//2
//statement bodies
nums.forEach(v => {
  if(v % 5 === 0) {
    fives.push(v);
  }
});

//3
//lexical this
var bob = {
  _name: "bob",
  _friends: [],
  printFriends() {
    this._friends.forEach(f => {
      console.log(this._name + ' knows' + f);
    });
  }
}

//4
//lexical arguments
function square () {
  let example = () => {
    let numbers = [];
    for(let number of arguments) {
      numbers.push(number * number);
    }
    
    return numbers;
  };
  
  return example();
}

```


### 二、Classes

JavaScript 的类是一个基于原型的面向对象模型，prototype-base OO，的语法糖。

To have a single convenient declarative form makes class patterns easier to use.

类支持：prototype-based inheritance, super calls, instance, static methods, constructors.


```javascript

class SkinnedMesh extends THREE.Mesh {
  constructor(geometry, materials) {
    super(geometry, materials);
    
    this.idMatrix = SkinnedMesh.defaultMatrix();
    this.bones = [];
    this.boneMatrices = [];
  }
  
  update(camera) {
    //...
    super.update();
  }
  
  //static 方法只能由当前类来访问
  static defaultMatrix() {
    return new THREE.Matrix4();
  }
}

```

### 三、对象字面量扩展

支持：setting the prototype at construction, shorthand for `foo: foo` assginments, defining methods and making super calls, computed (dynamic) property names.

```javascript

var foo = 1, theProtoObj, somethingElse;

var obj = {

  //1
  //sets the prototype
  __proto__: theProtoObj,
  
  //2
  //duplicate __proto__ properties
  ['__proto__']: somethingElse,
  
  //3
  //shorthand for 'foo: foo'
  foo,
  
  //4
  //super calls
  toString() {
    return "d " + super.toString();
  },
  
  //5
  //computed (dynamic) property names
  ["prop_" + (() => 42)()]: 42
}

```

### 四、模板字符串

template strings, provide syntactic sugar for constructing strings.

```javascript

//1
//basic template string creation
`this is a template string`

//2
//multiline strings
`in ecmascript 5 this is
not legal.`

//3
//interpolate variable bindings
var name = 'test';
`hello, ${name}`;

//4
//unescape template strings
String.raw`In ecmascript 5 "\n" is a line-feed.`
//String.raw() 是唯一一个内置的模板字符串的标签函数，tag function，用来获取一个模板字符串的原始字符串的，且任何类型的转义形式都会失效。通常不需要把它看成一个普通函数，你只需要把它放在模板字符串前面就可以了，而不是在它后面加个括号和一堆参数来调用它，引擎会替你去调用它。

```

### 五、解构赋值

Restructuring, allows binding using pattern matching, with support for matching arrays and objects.

```javascript

//1
//list matching
var [a, b] = [1, 2, 3];
a === 1
b === 3;

//2
//object matching
var test = {
  a: "a",
  b: "b"
}
var {
  a,
  b,
} = test;
a = "a"
b = "b"

//3
//can be used in parameter position
function g({name: x}) {
  console.log(x);
}
g({name: 5});

//4
//destructuring + defaults arguments
function r({x, y, z = 10}) {
  ...
}
r({x:1, y:2});

//5
//fail-soft feature
var [a] = [];
a === undefined

var [b=1] = [];
b === 1

```


### 六、let + const

let is the new var.

const is single-assignment.

let和const的设计，就是为了让 JavaScript 程序员养成良好的编程习惯。

fetures:

- 基于词法作用域

- 变量必须在声明处后才能使用，因为引入了暂时性死区，temporal dead zone，如果区块中存在let或const命令，这个区块对于这些命令声明的变量，从一开始就形成了封闭作用域，所以凡是在块内声明之前使用都会报错，就算该变量在外部定义了

- t不允许在同一个作用域内重复声明一个同名变量


```javascript

function f() {
  {
    let x;
    
    //a new block scope
    {
      const x = 'ok';
      
      //error
      //it was just defined with const before
      x = "error";
    }
    
    x = "ok";
    
    //error
    //already declared above in this block
    let x = "error";
  }
}

```

### 七、Iterators

迭代器对象，支持自定义迭代。

```javascript

let fibonacci = {
  [Symbol.iterator]() {
    let pre = 0, cur = 1;
    
    return {
      next() {
        [pre, cur] = [cur, pre + cur];
        
        return { done: false, value: cur }
      }
    }
  }
}

for (var n of fibonacci) {

  if(n > 1000) {
    break;
  }
  
}

```

注意，iteration is based on these duck-type interface：

```typescript

interface IteratorResult {
  done: boolean;
  value: any;
}

interface Iterator {
  next(): IteratorResult;
}

interface Iterable {
  [Symbol.iterator](): Iterator
}

```


### 八、Generators

Generators simplify iterator-authoring using `function*` and `yield`, which include `next` and `throw`.

Generators are subtypes of iterators.

A function declared as `function*` return a Generator instance.


```javascript

var fibonacci = {
  [Symbol.iterator]: function*() {
    var pre = 0, cur = 1;
    
    for(;;) {
      var temp = pre;
      pre = cur;
      cur += temp;
      
      yield cur;
    }
  }
}

for(var n of fibonacci) {
  if(n > 1000) break;
}

```

注意，the generator interfaces is：

```javascript

interface Generator extends Iterator {
  next(value?: any): IteratorResult;
  throw(exception: any);
}

```

### 九、Modules

Language-level support for modules for component definition.

在 ECMAScript 2015 之前，模块化实现方式有许多，各有优缺点。

注意，Babel 会将 ES2015 的 Modules 代码转换为特定的 Common.js or AMD 等形式，甚至可以转换成自定义模块化形式。

```javascript

//1

//lib/math.js
export function sum(x, y) {
  return x + y;
}

export var pi = 3.141593;

//app.js
import * as math from "lib/math";
2π = math.sum(math.pi, math.pi);

//other.js
import { sum, pi } from 'lib/math';
2π = sum(pi, pi);


//2
//export default and export *

//lib/mathplus.js
export * from "lib/math";
export var e = 2.71828182846;
export default function(x) { return Math.exp(x); }

//app.js
import myExp, { pi, e } from 'lib/mathplus';
e^π = exp(pi);

```

### 十、Proxies

Proxies enable creation of objects with the full range of behaviors available to host objects.

换句话说，Proxies 允许创建对象，这些对象具有宿主对象可以使用的全部行为。

Proxies can be used for interception, object virtualization, logging(记录)/profiling(分析), etc.


```javascript

//1
//Proxying a normal object
var target = {};
var handler = {
  get: function(receiver, name) {
    return `hello, ${name}!`;
  }
};

var p = new Proxy(target, handler);
p.world === "hello, world!"


//2
//Proxying a function object
var target = function () {
  return "i am the target";
};
var handler = {
  apply: function (receiver, ...args) {
    return "i am the proxy";
  }
};

var p = new Proxy(target, handler);
p() === 'i am the proxy'

```

除了 `get` 和 `apply`，there are traps available for all of the runtime-level meta-operations

```javascript

var handler = {

  //1
  //target.prop
  get: ...,
  
  //2
  //target.prop = value
  set: ...,
  
  //3
  //delete target.prop
  deleteProperty: ...,
  
  //4
  //target(...args)
  apply: ...,
  
  //5
  //new target(...args)
  construct: ...,
  
  //6
  //Object.getOwnPropertyDescriptor(target, 'prop')
  getOwnPropertyDescriptor: ...,
  
  //7
  //Object.defineProperty(target, 'prop', descriptor)
  defineProperty: ...,
  
  //8
  //Object.getPrototypeOf(target)
  //Reflect.getPrototypeOf(target)
  //target.__proto__
  //object.isPrototypeOf(target)
  //object instanceof target
  getPrototypeOf: ...,
  
  //9
  //Object.setPrototypeOf(target)
  //Reflect.setPrototypeOf(target)
  setPrototypeOf: ...,
  
  //10
  //for (let i in target) {}
  enumerate: ...,
  
  //11
  //Object.keys(target)
  ownKeys: ...,
  
  //12
  //Object.preventExtensions(target)
  preventExtensions: ...,
  
  //13
  //Object.isExtensible(target)
  isExtensible: ...,
}

```




### 十一、Map + Set + WeakMap + WeakSet

These are efficient structures for common algorithms.

```javascript

//1
//Sets
var s = new Set();
s.add("hello").add("goodbye").add("hello");
s.size === 2;
s.has("hello") === true;

s === Set(2) {"hello", "goodbye"}

//2
//Maps
var m = new Map();
m.set("hello", 21);
m.set(s, 21);
m.get(s) === 21

//3
//Weak Maps
var wm = new WeakMap();
vm.set(s, { extra: 42 });
vm.size === undefined
vm.get(s) === { extra: 42 }

//WeakMaps provides leak-free object-key'd side tables
//WeakMaps 提供无泄漏的对象键的副表

//4
//Weak Sets
var ws = new WeakSet();
ws.add({ data: 21 });
//because the added object has no other references, it will not be held in the set

```


### 十二、Symbols

Symbols 是一个 ECMAScript 2015 引入的一个 primitive type。

Symbols enable access control for object state.

Symbols allow properties to be keyed by either `string` or `symbol`.

Symbols are unique, but not private since they are exposed via reflection features like `Object.getOwnPropertySymbols`.

```javascript

(function() {

  //module scoped symbol
  var key = Symbol("key");
  
  function MyClass(privateData) {
    this[key] = privateData;
  }
  
  MyClass.prototype = {
    doStuff: function() {
      ... this[key] ...
    }
  };
  
  //limited support from Babel, full support requires native implementation
  typeof key === "symbol"
})();

var c = new MyClass("hello");
c["key"] === undefined

```


### 十三、Subclassable Built-ins

`built-ins` like `Array`, `Date` and  DOM `element`s can be subclassed.

```javascript

//User code of Array subclass
class MyArray extends Array {
  constructor(...args) {
    super(...args);
  }
}

var arr = new MyArray();
arr[1] = 12;

arr.length == 2

```

### 十四、Math、Number、String、Object的扩展

```

//1
//Math
Math.hypot(3, 4);
...

//2
//Number
Number.isInteger();
Number.isNaN();
...

//3
//String
"test".includes("cd"); //true
"test".repeat(3); //"testtesttest"

//4
//Array

//return a real Array
Array.from(document.querySelectorAll('*'));

//Similar to new Array(...), but without special one-argument behavior.
//比如 new Array(3) === [,,]，而不是 [3]
Array.of(1, 2, 3)

[0, 0, 0].fill(7, 1); //[0, 7, 7]

[1, 2, 3].findIndex(x => x == 2); //1

["a", "a", "a"].entries()

["a", "a", "a"].keys()

["a", "a", "a"].values()

//5
//Object
Object.assign(Point, { origin: new Point(0, 0) })

```


### 十五、Promises

Promises are a library for asynchronous programming. 

```
function timeout(duration = 0) {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, duration);
    })
}

var p = timeout(1000).then(() => {
    return timeout(2000);
}).then(() => {
    throw new Error("hmm");
}).catch(err => {
    return Promise.all([timeout(100), timeout(200)]);
})

```

### 十六、Reflect API

This is effectively the inverse of the Proxy API, and allows making calls corresponding to the same meta-operations as the proxy traps.

It is Especially useful for implementing proxies.

```

var Obj = {a: 1};
Object.defineProperty(Obj, 'b', {value: 2});
Obj[Symbol('c')] = 3;

Reflect.ownKeys(Obj); //['a', 'b', Symbol(c)]

functino C(a, b) {
  this.c = a+b;
}

var instance = Reflect.construct(C, [20, 22]);
instance.c; //42

```


### 十七、Tail Calls

尾调用，函数最后一步执行一个函数。

Calls in tail-position are guaranteed to not grow the stack unboundedly.

Makes recursive algorithms safe in the face of unbounded inputs.

```

//1
//common recursive
function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}
factorial(5)
(5*factorial(4))
(5*(4*factorial(3)))
(5*(4*(3*factorial(2))))
(5*(4*(3*(2*factorial(1)))))
(5*(4*(3*2)))
(5*(4*(6)))
(5*24)
120

普通递归实现的阶乘，其执行过程中不断的调用自身，导致一直没有返回，这样会不断的在栈中存储调用记录。而当调用自身的次数过多后，就会产生“栈溢出”。


//2
//tail calls recursive
function factorial(n, acc=1) {
  if(n<=1) return acc;
  return factorial(n-1, n*acc);
}
factorial(5)
(factorial(4, 5*1))
(factorial(3, 4*5))
(factorial(2, 20*3))
(factorial(1, 60*2))
120

这种方式只有一个调用记录，调用函数产生一个调用记录，最后一步操作执行一个新的函数，把当前函数的计算结果当做参数传递给它，这样当前函数调用产生的调用记录就消失了，因为它执行完了，这样就不会溢出。
   
```

