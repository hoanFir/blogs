🐾 前端模块化和模块化规范发展

🕘 2019.10.30 由 hoanfirst 编辑

模块化主要包含两部分内容

1. 模块化

2. 模块化规范


### 一、什么是模块化

将一个复杂的程序依据一定规范封装成几个文件，并打包在一起。

模块内部的数据/实现是私有的，通过暴露一些接口与外部其他模块进行通信。



### 二、为什么要使用模块化

web 应用越来越复杂，解耦性需求越来越高，公共内容复用和可维护性要求也越来越高，and deployment wants optimized code in few HTTP calls，要求实现动态/按需加载。



### 三、模块化发展历程

Stage - 1 - 文件划分方式

```

- stage-1
  - moduleA.js
  - moduleB.js
  - index.html

```

最早，各个模块逻辑代码都是各自放在一个js里面。

moduleA.js

```javascript

function foo() {}

```

moduleB.js

```javascript

var data = 'b'

```

index.html

```html

<head>
  <script src="moduleA.js"></script>
  <script src="moduleB.js"></script>
  <script>
    foo();
    data = "c";
  </script>
</head>

```

存在的问题：

```

1. 模块直接在全局工作，大量模块成员污染全局作用域

2. 没有私有空间，模块成员容易在外部被访问或修改

3. 容易出现命名冲突

4. 无法管理模块之间的依赖关系

5. 在维护过程中很难理清每个成员所属的模块

```


Stage - 2 - 命名空间方式

后来，出现了简单的命名空间，即 namespace。约定每个模块只能暴露一个全局对象，所有成员都挂在到该对象里。


moduleA.js

```javascript

window.namespaceA = {}

```

moduleB.js

```javascript

window.namespaceB = {
  data: 'b';
}

```

改进：

```

解决了命名冲突的问题。

```


Stage - 3 - IIFE

接着，出现了 IIFE(Immediately Invoked Function Expression, 立即执行函数表达式)。基于立即执行函数，为模块提供一个私有的空间。

moduleA.js

```javascript

;(function() {
  var data = 'a';
  
  function method () {
    console.log(data)
  }
  
  window.moduleA = {
    method: method
  }
})()

```

moduleB.js

```javascript

;(function() {
  var data = 'b';
  
  function method () {
    console.log(data)
  }
  
  window.moduleB = {
    method: method
  }
})()

```

index.html

私有成员 data 只能在模块内部通过闭包的方式来访问。

```html

<script src="moduleA.js"></script>
<script src="moduleB.js"></script>
<script>
  ModuleA.method();
  ModuleA.data; //undefined
</script>

```

改进：

```

解决没有私有空间的问题。

```


Stage - 4 - IIFE 依赖参数


最后，在 IIFE 基础上，通过参数引入了“依赖”概念。

这就是`模块模式`。**模块模式是现代模块实现的基石**。

```javascript

;(function(window, $){
  var _private = 'safe var',
  var foo = function(){ console.log(_private); }
  
  window.module = { foo };
  
  $('body').css('background', 'red');
  
})(window, jQuery);

```

index.html

```html

<script>

module.foo(); 

</script>

```


改进：

```

理清模块的依赖关系。

```



### 四、页面引入模块出现的问题

上述几种方式解决了实现模块化的一些问题，但是，**主要是优化模块组织，对于模块加载问题，并没有解决**。


- 模块过多造成页面请求 js 过多

- 由于依赖关系，有些模块引入顺序不可更改

- 某个模块在 html中被忘记引入，或者移除了某个模块但是在html中还保留着

- 难以维护


### 五、模块化规范

上述几种方式是通过**约定**实现模块化的方式，不同的开发者在实施的过程中会出现一些细微的差别。为了统一不同开发者和不同项目之间的差异，就需要制定一个行业标准去规范模块化的实现方式。

模块化规范的出现两个需求：

1. 一个统一的模块化标准规范

2. 一个可以自动加载模块的基础库


- CommonJS 规范

CommonJS 是 NodeJS 所遵循的模块化规范。通过 `module.exports` 导出成员，再通过 `require` 载入模块。

CommonJS

在浏览器端主要是通过Browserify实现，也称为CommonJS的浏览器端的打包工具。因为在服务器端模块加载是运行时**同步加载**的，这种同步机制在浏览器端用户体验是很不友好的，因此在浏览器端模块一般需要提前编译打包处理。

```javascript

//暴露
module.exports = value;

exports.xxx = value;

```

```javascript

//引入
require(xxx)

```



- AMD

AMD，Asynchronous Module Definition模块化规范专门用于浏览器端，模块的加载是异步的。

```javascript

//暴露模块

define(function(){
  return ...
})

define(['module1', 'module2'], function(m1, m2) {
  return ...
})

```

```javascript

//引入模块

require([''module1, 'module2'], function(m1, m2) {
  ...
})

```

AMD实现，RequireJS(a js file and module loader)。

```javascript

//app.js
(function() {
  requirejs.config({
    baseUrl: 'js/', //基本路径，出发点在根目录下
    paths: { //配置模块路径
        app: './app',
        other: './modules/other',
        jquery: './lib/jquery-1.10.1'
    }
  })
  
  requirejs(['jquery', 'canvas', 'app/sub'], function($, canvas, sub){
    //loaded and can be used here now.
  }) 
})();

```

- ES6

ES2015+引入的模块化规范。

依赖模块的过程同CommonJS在浏览器端一样需要编译打包处理。

因为ES6在一些浏览器还不支持，需要使用babel转化成ES5，而ES5的`export`、`require`还需要用上面提到的`Browserify`来支持。

1. 安装：

```bash

npm i babel-cli -g //cli: command line interface. babel-cli支持直接使用babel的命令

npm i browserify -g

npm i babel-preset-es2015 --save-dev //将es6转化成es5的工具都下载好

```

2. babelrc and Browserify：


```json

//rc: run control
{
  'presets': ['es2015', 'react']
}

```

```bash

//run
babel js/src -d js/lib

browserify js/lib/app.js -o js/lib/bundle.js

```

3. 语法

```javascript

//分别暴露(常规暴露)
export function foo() {}
export function bar() {} 
export let arr = []
 
//统一暴露(常规暴露)
function fun1() {}
function fun2() {} 
export { fun1, fun2 };

//引入常规暴露需要使用解构赋值
import { foo, bar } from './module1';
import { fun1, fun2 } from './module2'; 

//(默认暴露)
export default fun;

//引入默认暴露
import xxx from './module2'

```

