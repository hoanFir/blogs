
## 方案：Promise.all()

```javascript

function resolveAfter2Seconds() {
  return new Promise(resolve => {
    setTimeout(function() {
      resolve("slow")
      console.log("slow promise is done")
    }, 2000)
  })
}

function resolveAfter1Second() {
  return new Promise(resolve => {
    setTimeout(function() {
      resolve("fast")
      console.log("fast promise is done")
    }, 1000)
  })
}

//1
//concurrent
function concurrentPromise() {
  return Promise.all([resolveAfter2Seconds(), resolveAfter1Second()]).then((messages) => {
    // Promise.all 会在所有任务执行完且成功后才执行then
    
    console.log(messages[0]) //this runs 2 seconds after
    console.log(messages[1]) //this runs 2 seconds after, immediately because fast is already resolved
  })
}

```

In concurrentPromise, both timers are created and then awaited. The timers run concurrently, which means the code finishes in 2 seconds. However, it still run in series, which means the second await will wait for the first one to finish.

所以上述代码其实并不是真正的并行，而是并发，只是在宏观上好像是同时运行的，在微观上还是轮流执行的。


## 改进方案：parallel = async/wait + Promise.all()

If we wish to safely perform two or more jobs in parallel, we must await a call to Promise.all, or Promise.allSettled.

```javascript

//2
async function parallel() {
 
  await Promise.all([
      (async ()=>console.log(await resolveAfter2Seconds()))(),
      (async ()=>console.log(await resolveAfter1Second()))()
  ])
  
  //truly parallel: after 1 second, logs "fast", then after 1 more second, "slow"
}

```
